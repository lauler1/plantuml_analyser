import inspectimport astimport tokenizeimport ioimport sysdef get_call_names(node):    # Retrieve all function names from the node    return [get_call_name(child) for child in ast.walk(node) if isinstance(child, ast.Call)]def get_call_name(node):    if isinstance(node.func, ast.Name):        # Direct function call, e.g., print()        return node.func.id    elif isinstance(node.func, ast.Attribute):        # Method call, e.g., x.append()        return node.func.attr    return None    def get_participant_tree_from_func_name(func_name, participants):    if not func_name in participants:        return None    source_code = inspect.getsource(participants[func_name])    return ast.parse(source_code)def proc_Call(node, name, caller_name, participants, idx, **kwargs):    func_name = get_call_name(node)        if not func_name in participants:        return    # Extract the positional arguments    arg_list = [ast.unparse(arg) for arg in node.args]        # Extract the keyword arguments    kw_args = {kw.arg: ast.unparse(kw.value) for kw in node.keywords}    for key, value in kw_args.items():        arg_list.append(f"{key}={value}")    args = (", ".join(arg_list))        print(f"{name}->{func_name}: {args}")    print(f"activate {func_name}")        new_tree = get_participant_tree_from_func_name(func_name, participants)    proc_plantuml_sequence_node(new_tree, func_name, name, participants, idx, **kwargs)def proc_Args(node, name, caller_name, participants, idx, **kwargs):    if not node.body or not isinstance(node.body[-1], ast.Return):        node.body.append(ast.Return(value=None))    proc_plantuml_sequence_node(node.body, name, caller_name, participants, idx+1, **kwargs)def proc_Return(node, name, caller_name, participants, idx, **kwargs):    if caller_name:        if node.value:            if isinstance(node.value, ast.Tuple):                return_values = ",".join([ast.unparse(el) for el in node.value.elts])            else:                return_values = ast.unparse(node.value)            print(f"{name}-->{caller_name}: {return_values}")            # print(f"------> return: {return_values}; <<output>>")        else:            print(f"{name}-->{caller_name}:")        print(f"deactivate {name}")def proc_If(node, name, caller_name, participants, idx, **kwargs):    has_body_relevant_call = False    has_orelse_relevant_call = False    # Check if there is a Call node in the body of the While loop    for child in ast.walk(node):        if isinstance(child, ast.Call):            if get_call_name(child) in participants:                has_body_relevant_call = True    # Check if there is a Call node in the body of the Else statement            for child in node.orelse:        if any(isinstance(grandchild, ast.Call) for grandchild in ast.walk(child)):            calls_in_else = (get_call_names(child))            for child_name in calls_in_else:                if child_name in participants:                    has_orelse_relevant_call = True    if has_body_relevant_call or has_orelse_relevant_call:        print(f"alt {ast.unparse(node.test)}")    proc_plantuml_sequence_node(node.body, name, caller_name, participants, idx+1, **kwargs)    if has_orelse_relevant_call:        print(f"else")    proc_plantuml_sequence_node(node.orelse, name, caller_name, participants, idx+1, **kwargs)    if has_body_relevant_call or has_orelse_relevant_call:        print("end")def proc_For(node, name, caller_name, participants, idx, **kwargs):    has_body_relevant_call = False    has_orelse_relevant_call = False    # Check if there is a Call node in the body of the While loop    for child in ast.walk(node):        if isinstance(child, ast.Call):            if get_call_name(child) in participants:                has_body_relevant_call = True    # Check if there is a Call node in the body of the Else statement            for child in node.orelse:        if any(isinstance(grandchild, ast.Call) for grandchild in ast.walk(child)):            calls_in_else = (get_call_names(child))            for child_name in calls_in_else:                if child_name in participants:                    has_orelse_relevant_call = True    if has_body_relevant_call or has_orelse_relevant_call:        print(f"loop {ast.unparse(node.iter)}")    proc_plantuml_sequence_node(node.body, name, caller_name, participants, idx+1, **kwargs)    if has_orelse_relevant_call:        print(f"else")    proc_plantuml_sequence_node(node.orelse, name, caller_name, participants, idx+1, **kwargs)    if has_body_relevant_call or has_orelse_relevant_call:        print("end")def proc_While(node, name, caller_name, participants, idx, **kwargs):    has_body_relevant_call = False    has_orelse_relevant_call = False    # Check if there is a Call node in the body of the While loop    for child in ast.walk(node):        if isinstance(child, ast.Call):            if get_call_name(child) in participants:                has_body_relevant_call = True    # Check if there is a Call node in the body of the Else statement            for child in node.orelse:        if any(isinstance(grandchild, ast.Call) for grandchild in ast.walk(child)):            calls_in_else = (get_call_names(child))            for child_name in calls_in_else:                if child_name in participants:                    has_orelse_relevant_call = True    if has_body_relevant_call or has_orelse_relevant_call:        print(f"loop {ast.unparse(node.test)}")    proc_plantuml_sequence_node(node.body, name, caller_name, participants, idx+1, **kwargs)    if has_orelse_relevant_call:        print(f"else")    proc_plantuml_sequence_node(node.orelse, name, caller_name, participants, idx+1, **kwargs)    if has_body_relevant_call or has_orelse_relevant_call:        print("end")# Function to recursively sequence node the ASTdef proc_plantuml_sequence_node(node, name, caller_name, participants, idx, **kwargs):    # Options    max_rec = 20    if 'max_rec' in kwargs:        max_rec = kwargs['max_rec']      if idx > max_rec:        print("Maximal recursive calls reached.", file=sys.stderr)        return          if isinstance(node, list):        for item in node:            proc_plantuml_sequence_node(item, name, caller_name, participants, idx, **kwargs)    elif isinstance(node, ast.AST):        # print(f"--> {node.__class__.__name__}(")                if(node.__class__.__name__ == "Call"):            proc_Call(node, name, caller_name, participants, idx, **kwargs)        elif(node.__class__.__name__ == "FunctionDef"):            proc_Args(node, name, caller_name, participants, idx, **kwargs)        elif(node.__class__.__name__ == "Return"):            proc_Return(node, name, caller_name, participants, idx, **kwargs)                    elif(node.__class__.__name__ == "If"):            proc_If(node, name, caller_name, participants, idx, **kwargs)        elif(node.__class__.__name__ == "For"):                proc_For(node, name, caller_name, participants, idx, **kwargs)        elif(node.__class__.__name__ == "While"):            proc_While(node, name, caller_name, participants, idx, **kwargs)                    else:            for field, value in ast.iter_fields(node):                # print(f"----> {field}=")                proc_plantuml_sequence_node(value, name, caller_name, participants, idx, **kwargs)# Function to recursively pretty-print the ASTdef pretty_print_ast(node, level=2):    indent="  "            if isinstance(node, list):        for item in node:            pretty_print_ast(item, level)    elif isinstance(node, ast.AST):        print(f"1) {indent * level}{node.__class__.__name__}(")               for field, value in ast.iter_fields(node):            print(f"2) {indent * (level + 1)}{field}=")            pretty_print_ast(value, level+1)        print(f"{indent * level})")    else:        print(f"3) {indent * level}{repr(node)},")def do_plantuml_sequence(*args, **kwargs):    """    This function creates a simple plantuml output representation of the sequence diagram among functions.    Usage:        do_plantuml_sequence((func_1, "Actor 1", "actor"), (func_2, "Participant 2", "participant"))        The furst callable is the main.    Argumnets:        args -- sequence of Tuples of the participants. Each Tuple contains 3 elements, Callable (e.g. functions) to be processed, a name for the item, and a plantuml type (e.g. actor, participant, database).        kwargs -- Optional key/value arguments.            max_rec -- Maximal recursive calls. Avoid infinit recursive calls.            title -- Add a title to the diagram.    """        # print(args)    print("@startuml")    print("hide footbox")        if 'title' in kwargs:        print(f"title {kwargs['title']}")        participants = {}    for idx, (callable, name, type) in enumerate(args):        key = callable.__name__ #"item_"+str(idx)        print(f"{type} \"{name}\" as {key}")        participants[key] = callable    func_name, first_callable = next(iter(participants.items()))            # print("example_sequence_1->example_sequence_2: Authentication Request")    tree = get_participant_tree_from_func_name(func_name, participants)    proc_plantuml_sequence_node(tree, func_name, None, participants, 0, **kwargs)    # for key, callable in items.items():        # # print("\n------------------------------------------------------------------------")        # source_code = inspect.getsource(callable)        # tree = ast.parse(source_code)        # proc_plantuml_sequence_node(tree, key, items, **kwargs)        # # pretty_print_ast(tree, level=0)            print("@enduml")    