import inspectimport astimport tokenizeimport ioimport sysimport linecacheclass EmptyBlockVisitor(ast.NodeTransformer):    """    Custom AST Visitor to detect and modify empty blocks with 'pass'    This class does one single thing, it replace all empty blocks of code by a 'pass' command in order to become traceable by activity_trace_function.    An empty block (or empty path) is any unused block (block with no instruction) for example in an else statement that is not declared. It can be shown in an activity diagram but is not traceable if there is no instruction inside.    """    def visit_If(self, node):        # Check if 'body' or 'orelse' are empty and add 'pass' if necessary        if not node.body:            node.body.append(ast.Pass())        if not node.orelse:            node.orelse.append(ast.Pass())        self.generic_visit(node)        return node    def visit_While(self, node):        # Check if 'body' or 'orelse' are empty and add 'pass'        if not node.body:            node.body.append(ast.Pass())        # else:            # self.generic_visit(node.body)        if not node.orelse:            node.orelse.append(ast.Pass())        # else:            # self.generic_visit(node.orelse)        self.generic_visit(node)        return node    def visit_For(self, node):        # Check if 'body' or 'orelse' are empty and add 'pass'        if not node.body:            node.body.append(ast.Pass())        if not node.orelse:            node.orelse.append(ast.Pass())        self.generic_visit(node)        return node    def visit_FunctionDef(self, node):        # Handle empty function bodies        if not node.body:            node.body.append(ast.Pass())        self.generic_visit(node)        return nodedef get_corrected_source_code(func):    """    Returns the source code of 'func' after using EmptyBlockVisitor to correct empty blocks.    """    source_code = inspect.getsource(func)        # Parse the source code into an AST    tree = ast.parse(source_code)    # Modify the AST to add 'pass' where necessary    transformer = EmptyBlockVisitor()    new_tree = transformer.visit(tree)    # Unparse the modified AST back to source code (Python 3.9+)    modified_code = ast.unparse(new_tree)        return modified_codedef activity_trace_function(func, *args, **kwargs):    """    Generic function to trace any function and store the result using a closure        The function executes func and colects data for do_plantuml_activity. The trace result allows do_plantuml_activity to highlights the simulated path of an activity diagram.    This function receives a 'func' to be executed and traced, all empty paths inside the 'func' are first replaced by the 'pass' command using EmptyBlockVisitor.    The results returned by func are packed in a tuple.        func: The function to be traced    *args: positional arguments for func    **kwargs: key value arguments for func    return: the result of the func (as a tuple for multiple returns) and the trace result.    """    trace_results = []  # Initialize an empty list to store trace results    # Trace function defined as a closure to capture trace_results    def trace_func(frame, event, arg):        if event == "line":            lineno = frame.f_lineno            filename = frame.f_code.co_filename            line = linecache.getline(filename, lineno).strip()            trace_results.append(lineno)            # print(f"{filename}{lineno}: {line}")            # trace_results[f'{lineno}'] = f"Executing: {line}"        return trace_func    source_code = get_corrected_source_code(func)        # print("###########################################################")    # print(modified_code)    # print("###########################################################")        compiled_code = compile(source_code, '<string>', 'exec')    # Prepare a namespace to store the executed function    namespace = {}    exec(compiled_code, namespace)  # Execute the compiled code in the given namespace        # print ("\n start trace")    # Set the trace function    sys.settrace(trace_func)        # Run the target function with the provided arguments    # result = func(*args, **kwargs)    # print ("\n namespace")    result = namespace['example_function'](*args, **kwargs)        # Stop tracing    sys.settrace(None)                # print ("trace_results = ", trace_results)        # for key, val in trace_results.items():        # print(f'{key} -> {val}')        return result, trace_resultsdef extract_comments_with_positions(source_code):    """    This function simply return a list of Tuples (line number, comment) inside the function.    It can be used to add notes to plantuml    """    comments = []    tokens = tokenize.generate_tokens(io.StringIO(source_code).readline)    for token in tokens:        if token.type == tokenize.COMMENT:            comments.append((token.start[0], token.string))  # (line number, comment)    return commentsdef add_comments(node, level=0, comments=[]):    if hasattr(node, 'lineno'):        node_line = node.lineno        #print("node_line", node_line)        for (line, comment) in comments:            if line == node_line:                cleaned_comment = comment.lstrip("# ").rstrip()                print(f"{' ' * level}note right: {cleaned_comment}")def add_bold_line(node, level=0, trace_result=[]):    if hasattr(node, 'lineno') and len(trace_result) > 0:        node_line = node.lineno        print(f"' node_line = {node_line} of type {type(node_line)}")        # print(f"' trace_result = {trace_result}")        #print(f"{' ' * level}note right: {cleaned_comment}")        if node_line in trace_result:            print(f"{' ' * level}-[#blue,bold]->")            return True    return Falsedef get_call_name(node):    if isinstance(node.func, ast.Name):        # Direct function call, e.g., print()        return node.func.id    elif isinstance(node.func, ast.Attribute):        # Method call, e.g., x.append()        return node.func.attr    return Nonedef proc_Call(node, level=0, comments=[], trace_result=[], **kwargs):    func_name = get_call_name(node)    if 'filter_call' in kwargs:        filter = kwargs['filter_call']        if func_name in filter:            return    add_bold_line(node, level, trace_result)    print(f"{' ' * level}:{func_name};")    add_bold_line(node, level, trace_result)    add_comments(node, level, comments)def proc_Args(node, level=0, comments=[], trace_result=[], **kwargs):    arg_names = []    # Extract argument names    for arg in node.args.args:        arg_names.append(arg.arg)        # Extract keyword-only arguments    for kwarg in node.args.kwonlyargs:        arg_names.append(kwarg.arg)        # Extract variable positional and keyword arguments (*args, **kwargs)    if node.args.vararg:        arg_names.append(node.args.vararg.arg)    if node.args.kwarg:        arg_names.append(node.args.kwarg.arg)        arg_names_str = ",".join(arg_names)    add_bold_line(node, level, trace_result)    print(f"{' ' * level}:{arg_names_str}; <<input>>")    add_bold_line(node, level, trace_result)    add_comments(node, level, comments)    if not node.body or not isinstance(node.body[-1], ast.Return):        # Append a return statement if the last statement is not a return        node.body.append(ast.Return(value=None))    proc_plantuml_activity_node(node.body, level, comments, trace_result, **kwargs)def proc_Assign(node, level=0, comments=[], trace_result=[], **kwargs):    add_bold_line(node, level, trace_result)    print(f"{' ' * level}:{ast.unparse(node)};")    add_bold_line(node, level, trace_result)    add_comments(node, level, comments)def proc_While(node, level=0, comments=[], trace_result=[], **kwargs):    add_bold_line(node, level, trace_result)    print(f"{' ' * level}while (while {ast.unparse(node.test)}) is (Y)")    add_comments(node, level, comments)    proc_plantuml_activity_node(node.body, level + 2, comments, trace_result, **kwargs)    print(f"{' ' * level}endwhile (N)")    proc_plantuml_activity_node(node.orelse, level + 2, comments, trace_result, **kwargs)def proc_If(node, level=0, comments=[], trace_result=[], **kwargs):    add_bold_line(node, level, trace_result)    print(f"{' ' * level}if ({ast.unparse(node.test)}) then (Y)")    add_comments(node, level+2, comments)    proc_plantuml_activity_node(node.body, level + 2, comments, trace_result, **kwargs)    print(f"{' ' * level}else (N)")    proc_plantuml_activity_node(node.orelse, level + 2, comments, trace_result, **kwargs)    print(f"{' ' * level}endif")def proc_For(node, level=0, comments=[], trace_result=[], **kwargs):    add_bold_line(node, level, trace_result)    print(f"{' ' * level}while (for {ast.unparse(node.iter)}) is (Y)")    add_comments(node, level, comments)    proc_plantuml_activity_node(node.body, level + 2, comments, trace_result, **kwargs)    print(f"{' ' * level}endwhile (End)")    proc_plantuml_activity_node(node.orelse, level + 2, comments, trace_result, **kwargs)def proc_Break(node, level=0, comments=[], trace_result=[], **kwargs):    add_bold_line(node, level, trace_result)    print(f"{' ' * level}break;")    add_comments(node, level, comments)def proc_Pass(node, level=0, comments=[], trace_result=[], **kwargs):    add_bold_line(node, level, trace_result)    # print(f"{' ' * level}break;")    # add_comments(node, level, comments)def proc_Return(node, level=0, comments=[], trace_result=[], **kwargs):    if node.value:        if isinstance(node.value, ast.Tuple):            return_values = ",".join([ast.unparse(el) for el in node.value.elts])        else:            return_values = ast.unparse(node.value)        add_bold_line(node, level, trace_result)        print(f"{' ' * level}:{return_values}; <<output>>")    add_bold_line(node, level, trace_result)    print(f"{' ' * level}stop")    add_comments(node, level, comments)# Function to recursively activity node the ASTdef proc_plantuml_activity_node(node, level=1, comments=[], trace_result=[], **kwargs):    # print(f"' trace_result = {trace_result}")    indent="  "    # Options    ret = True    args = True    call = True    assign = True    augassign = True    annassign = True    if 'ret' in kwargs:        ret = kwargs['ret']    if 'args' in kwargs:        args = kwargs['args']    if 'call' in kwargs:        call = kwargs['call']    if 'assign' in kwargs:        assign = kwargs['assign']    if 'augassign' in kwargs:        augassign = kwargs['augassign']    if 'annassign' in kwargs:        annassign = kwargs['annassign']          if isinstance(node, list):        for item in node:            proc_plantuml_activity_node(item, level, comments, trace_result, **kwargs)    elif isinstance(node, ast.AST):                if(node.__class__.__name__ == "If"):            proc_If(node, level, comments, trace_result, **kwargs)        elif(node.__class__.__name__ == "Call") and call:            proc_Call(node, level, comments, trace_result, **kwargs)        elif(node.__class__.__name__ == "For"):            proc_For(node, level, comments, trace_result, **kwargs)        elif(node.__class__.__name__ == "FunctionDef") and args:            proc_Args(node, level, comments, trace_result, **kwargs)        elif(node.__class__.__name__ == "Assign") and assign:            proc_Assign(node, level, comments, trace_result, **kwargs)        elif(node.__class__.__name__ == "AugAssign") and augassign:            proc_Assign(node, level, comments, trace_result, **kwargs)        elif(node.__class__.__name__ == "AnnAssign") and annassign:            proc_Assign(node, level, comments, trace_result, **kwargs)        elif(node.__class__.__name__ == "While"):            proc_While(node, level, comments, trace_result, **kwargs)        elif(node.__class__.__name__ == "Pass"):            proc_Pass(node, level, comments, trace_result, **kwargs)        elif(node.__class__.__name__ == "Break"):            proc_Break(node, level, comments, trace_result, **kwargs)        elif(node.__class__.__name__ == "Return") and ret:            proc_Return(node, level, comments, trace_result, **kwargs)        else:            for field, value in ast.iter_fields(node):                proc_plantuml_activity_node(value, level, comments, trace_result, **kwargs)# Function to recursively pretty-print the ASTdef pretty_print_ast(node, level=2):    indent="  "            if isinstance(node, list):        for item in node:            pretty_print_ast(item, level)    elif isinstance(node, ast.AST):        print(f"1) {indent * level}{node.__class__.__name__}(")               for field, value in ast.iter_fields(node):            print(f"2) {indent * (level + 1)}{field}=")            pretty_print_ast(value, level+1)        print(f"{indent * level})")    else:        print(f"3) {indent * level}{repr(node)},")def do_plantuml_activity(function, trace_result=[], **kwargs):    """    This function creates a simple plantuml output representation of the function activities.    Argumnets:        function -- A callable (e.g. a function) to be processed.        trace_result -- Optional trace list generated by calling function via activity_trace_function. It is used to highlight the lines of code which were executed with a bold blue line.        kwargs -- Optional key/value arguments.            filter_call -- a list of calls inside the function to be ignored in the output (e.g. `filter_call=['print']`).            ret -- Boolean to activate output for return statements (Default True).            args -- Boolean to activate output for arguments statement (Default True).            call -- Boolean to activate output for calls statements (Default True).            assign -- Boolean to activate output for assignment statements (Default True).            augassign -- Boolean to activate output for augmented assignment statements, e.g. `a += 1` (Default True).            annassign -- Boolean to activate output for assignment with annotation statements, e.g. `a: int = 1` (Default True).            comment -- Boolean to activate output for inline comments as notes. The comment must be in the same line number of the statement.        """    source_code = get_corrected_source_code(function)    # source_code = inspect.getsource(function)    tree = ast.parse(source_code)    comments = []    if 'comment' in kwargs:        if kwargs['comment']:            comments = extract_comments_with_positions(source_code)    # print("comments:", comments)    print("@startuml")    print("title", function.__name__)    # print("skinparam conditionStyle diamond")    # print("skinparam ConditionEndStyle hline")    print("start")    if len(trace_result) > 0:        print("-[#blue,bold]->")    # print(f"' trace_result = {trace_result}")    proc_plantuml_activity_node(tree, 1, comments, trace_result, **kwargs)    # print("stop")    print("@enduml")    # pretty_print_ast(tree, 1)    