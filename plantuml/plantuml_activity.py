import inspectimport astimport tokenizeimport iodef extract_comments_with_positions(source_code):    """    This function simply return a list of Tuples (line number, comment) inside the function.    It can be used to add notes to plantuml    """    comments = []    tokens = tokenize.generate_tokens(io.StringIO(source_code).readline)    for token in tokens:        if token.type == tokenize.COMMENT:            comments.append((token.start[0], token.string))  # (line number, comment)    return commentsdef add_comments(node, level=0, comments=[]):    if hasattr(node, 'lineno'):        node_line = node.lineno        #print("node_line", node_line)        for (line, comment) in comments:            if line == node_line:                cleaned_comment = comment.lstrip("# ").rstrip()                print(f"{' ' * level}note right: {cleaned_comment}")def get_call_name(node):    if isinstance(node.func, ast.Name):        # Direct function call, e.g., print()        return node.func.id    elif isinstance(node.func, ast.Attribute):        # Method call, e.g., x.append()        return node.func.attr    return Nonedef proc_Call(node, level=0, comments=[], **kwargs):    func_name = get_call_name(node)    if 'filter_call' in kwargs:        filter = kwargs['filter_call']        if func_name in filter:            return    print(f"{' ' * level}:{func_name};")    add_comments(node, level, comments)def proc_Args(node, level=0, comments=[], **kwargs):    arg_names = []    # Extract argument names    for arg in node.args.args:        arg_names.append(arg.arg)        # Extract keyword-only arguments    for kwarg in node.args.kwonlyargs:        arg_names.append(kwarg.arg)        # Extract variable positional and keyword arguments (*args, **kwargs)    if node.args.vararg:        arg_names.append(node.args.vararg.arg)    if node.args.kwarg:        arg_names.append(node.args.kwarg.arg)        arg_names_str = ",".join(arg_names)    print(f"{' ' * level}:{arg_names_str}; <<input>>")    add_comments(node, level, comments)    if not node.body or not isinstance(node.body[-1], ast.Return):        # Append a return statement if the last statement is not a return        node.body.append(ast.Return(value=None))    proc_plantuml_activity_node(node.body, level, comments, **kwargs)def proc_Assign(node, level=0, comments=[], **kwargs):    print(f"{' ' * level}:{ast.unparse(node)};")    add_comments(node, level, comments)def proc_While(node, level=0, comments=[], **kwargs):    print(f"{' ' * level}while ({ast.unparse(node.test)}) is (Y)")    add_comments(node, level, comments)    proc_plantuml_activity_node(node.body, level + 2, comments, **kwargs)    print(f"{' ' * level}endwhile (N)")    proc_plantuml_activity_node(node.orelse, level + 2, comments, **kwargs)def proc_If(node, level=0, comments=[], **kwargs):    print(f"{' ' * level}if ({ast.unparse(node.test)}) then (Y)")    add_comments(node, level+2, comments)    proc_plantuml_activity_node(node.body, level + 2, comments, **kwargs)    print(f"{' ' * level}else (N)")    proc_plantuml_activity_node(node.orelse, level + 2, comments, **kwargs)    print(f"{' ' * level}endif")def proc_For(node, level=0, comments=[], **kwargs):    print(f"{' ' * level}while ({ast.unparse(node.iter)}) is (Y)")    add_comments(node, level, comments)    proc_plantuml_activity_node(node.body, level + 2, comments, **kwargs)    print(f"{' ' * level}endwhile (N)")    proc_plantuml_activity_node(node.orelse, level + 2, comments, **kwargs)def proc_Break(node, level=0, comments=[], **kwargs):    print(f"{' ' * level}break;")    add_comments(node, level, comments)def proc_Return(node, level=0, comments=[], **kwargs):    if node.value:        if isinstance(node.value, ast.Tuple):            return_values = ",".join([ast.unparse(el) for el in node.value.elts])        else:            return_values = ast.unparse(node.value)        print(f"{' ' * level}:{return_values}; <<output>>")    print(f"{' ' * level}stop")    add_comments(node, level, comments)# Function to recursively activity node the ASTdef proc_plantuml_activity_node(node, level=1, comments=[], **kwargs):    indent="  "    # Options    ret = True    args = True    call = True    assign = True    augassign = True    annassign = True    if 'ret' in kwargs:        ret = kwargs['ret']    if 'args' in kwargs:        args = kwargs['args']    if 'call' in kwargs:        call = kwargs['call']    if 'assign' in kwargs:        assign = kwargs['assign']    if 'augassign' in kwargs:        augassign = kwargs['augassign']    if 'annassign' in kwargs:        annassign = kwargs['annassign']          if isinstance(node, list):        for item in node:            proc_plantuml_activity_node(item, level, comments, **kwargs)    elif isinstance(node, ast.AST):                if(node.__class__.__name__ == "If"):            proc_If(node, level, comments, **kwargs)        elif(node.__class__.__name__ == "Call") and call:            proc_Call(node, level, comments, **kwargs)        elif(node.__class__.__name__ == "For"):            proc_For(node, level, comments, **kwargs)        elif(node.__class__.__name__ == "FunctionDef") and args:            proc_Args(node, level, comments, **kwargs)        elif(node.__class__.__name__ == "Assign") and assign:            proc_Assign(node, level, comments, **kwargs)        elif(node.__class__.__name__ == "AugAssign") and augassign:            proc_Assign(node, level, comments, **kwargs)        elif(node.__class__.__name__ == "AnnAssign") and annassign:            proc_Assign(node, level, comments, **kwargs)        elif(node.__class__.__name__ == "While"):            proc_While(node, level, comments, **kwargs)        elif(node.__class__.__name__ == "Break"):            proc_Break(node, level, comments, **kwargs)        elif(node.__class__.__name__ == "Return") and ret:            proc_Return(node, level, comments, **kwargs)        else:            for field, value in ast.iter_fields(node):                proc_plantuml_activity_node(value, level, comments, **kwargs)# Function to recursively pretty-print the ASTdef pretty_print_ast(node, level=2):    indent="  "            if isinstance(node, list):        for item in node:            pretty_print_ast(item, level)    elif isinstance(node, ast.AST):        print(f"1) {indent * level}{node.__class__.__name__}(")               for field, value in ast.iter_fields(node):            print(f"2) {indent * (level + 1)}{field}=")            pretty_print_ast(value, level+1)        print(f"{indent * level})")    else:        print(f"3) {indent * level}{repr(node)},")def do_plantuml_activity(function, **kwargs):    """    This function creates a simple plantuml output representation of the function activities.    Argumnets:        function -- A callable (e.g. a function) to be processed.        kwargs -- Optional key/value arguments.            filter_call -- a list of calls inside the function to be ignored in the output (e.g. `filter_call=['print']`).            ret -- Boolean to activate output for return statements (Default True).            args -- Boolean to activate output for arguments statement (Default True).            call -- Boolean to activate output for calls statements (Default True).            assign -- Boolean to activate output for assignment statements (Default True).            augassign -- Boolean to activate output for augmented assignment statements, e.g. `a += 1` (Default True).            annassign -- Boolean to activate output for assignment with annotation statements, e.g. `a: int = 1` (Default True).            comment -- Boolean to activate output for inline comments as notes. The comment must be in the same line number of the statement.        """    source_code = inspect.getsource(function)    tree = ast.parse(source_code)    comments = []    if 'comment' in kwargs:        if kwargs['comment']:            comments = extract_comments_with_positions(source_code)    print("comments:", comments)    print("@startuml")    print("title", function.__name__)    print("start")    proc_plantuml_activity_node(tree, 1, comments, **kwargs)    # print("stop")    print("@enduml")    pretty_print_ast(tree, 1)    