import inspectimport astimport tokenizeimport iofrom pprint import pprintimport plantuml.plantuml_types as ptdef print_with_indent(text, indent):    print('    ' * indent + text)def print_plant_component(name, value, indent=0):    path = value.path    # print ("metadata_dict", value.metadata_dict, indent)    color = ""    if "color" in value.metadata_dict:        color = "#"+value.metadata_dict["color"]        if isinstance(value, pt.PlantumlActor):        print_with_indent(f"actor \"{name}\" as {path} ${path} {color}", indent)    elif isinstance(value, pt.PlantumlComponent):        print_with_indent(f"component \"{name}\" as {path} ${path} {color} {{", indent)    elif isinstance(value, pt.PlantumlInterface):        print_with_indent(f"interface \"{name}\" as {path} ${path} {color}", indent)    elif isinstance(value, pt.PlantumlPort):        print_with_indent(f"port \"{name}\" as {path} ${path} {color}", indent)    elif isinstance(value, pt.PlantumlActivity):        print_with_indent(f"agent \"{name}\" as {path} ${path} {color}", indent)def print_plant_comonnection(name, value, indent=0):    # path = value.path    # print ("metadata_dict", value.metadata_dict, indent)    color = ""    if "color" in value.metadata_dict:        color = "#"+value.metadata_dict["color"]        elif isinstance(value, pt.PlantumlConnection):        path1 = value.comp1.path        path2 = value.comp2.path        print_with_indent(f"{path1} -- {path2} {color} : {name}", indent)# Function to recursively pretty-print the ASTdef pretty_print_ast(node, level=2):    indent="  "            if isinstance(node, list):        for item in node:            pretty_print_ast(item, level)    elif isinstance(node, ast.AST):        print(f"1) {indent * level}{node.__class__.__name__}(")               for field, value in ast.iter_fields(node):            print(f"2) {indent * (level + 1)}{field}=")            pretty_print_ast(value, level+1)        print(f"{indent * level})")    else:        print(f"3) {indent * level}{repr(node)},")def is_primitive(value):    return isinstance(value, (int, float, str, bool))def is_container(obj):    """Check if the object is a container type."""    return isinstance(obj, (dict, list, tuple, set)) or hasattr(obj, '__dict__')def introspect_class(cls, depth=0):     def introspect(cls, indent):        for name, value in inspect.getmembers(cls):            if not inspect.isroutine(value) and not name.startswith('__'):                print_with_indent(f"{name}: {value}", indent)                introspect(value, indent+1)    print(f"Class: {cls.__name__}")    print("Documentation:", cls.__doc__)    print("\nBases:")    pprint(cls.__bases__)    print("===================================")    print("\n\nAttributes (excluding methods):")    introspect(cls, depth + 1)    print("\nEND")    print("===================================")def introspect_object(obj, depth=0):    # # print(f"Class: {obj.__class__.__name__}")    # # print("Documentation:", obj.__doc__)    # # print("Bases:")    # # pprint(obj.__class__.__bases__)    def introspect(obj, indent):        for name, value in inspect.getmembers(obj):            if not inspect.isroutine(value) and not name.startswith('__'):                print_with_indent(f"{name}: {value}", indent)                if is_container(value):                    introspect(value, indent+1)    print_with_indent(f"Object of type: {type(obj).__name__}", depth)    introspect(obj, depth)def join_path(path, name):    if path == "":        return name    else:        return path+"_"+namedef do_plantuml_architecture(plantuml_arch, **kwargs):    """    This function creates a simple plantuml output representation of the architecture.    if an element has no name, then the variable name will be automaticaly applied as name.    Argumnets:        plantuml_arch -- A class of a PlantumlType type.        kwargs -- Optional key/value arguments.    """    def introspect(obj, path, indent):        # print("path = ", path)        for name, value in inspect.getmembers(obj):            if not inspect.isroutine(value) and not name.startswith('__'):                if isinstance(value, pt.PlantumlType):                    if value.name == "":                        value.name = name                    value.path = join_path(path, name)                    if isinstance(value, pt.PlantumlConnection):                        if value.metadata_dict['hide'] == False and value.metadata_dict['remove'] == False:                            print_plant_comonnection(value.name, value, indent)                    else:                        print_plant_component(value.name, value, indent)                                    if not isinstance(value, pt.PlantumlConnection) and is_container(value):                    introspect(value, join_path(path, name), indent+1)                if isinstance(value, pt.PlantumlComponent):                    print_with_indent("}", indent)                if isinstance(value, pt.PlantumlType) and not isinstance(value, pt.PlantumlConnection) and value.metadata_dict['hide'] == True:                    print_with_indent(f"hide ${value.path}", indent)                if isinstance(value, pt.PlantumlType) and not isinstance(value, pt.PlantumlConnection) and value.metadata_dict['remove'] == True:                    print_with_indent(f"remove ${value.path}", indent)                if isinstance(value, pt.PlantumlType) and "note" in value.metadata_dict:                    note_path = value.path+"_note"                    print_with_indent(f"note \"{value.metadata_dict['note']}\" as {note_path}", indent)                    print_with_indent(f"{note_path} ~ {value.path}", indent)    print("@startuml")        if "skinparam" in plantuml_arch.metadata_dict:        print(plantuml_arch.metadata_dict["skinparam"])    introspect(plantuml_arch, "", 0)    print("@enduml")